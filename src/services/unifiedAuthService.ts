// Servi√ßo unificado de autentica√ß√£o que gerencia localStorage, cookies e Redis
import { CookieManager } from '@/utils/cookieManager';
import { SessionService, SessionData } from './sessionService';
import { getDashboardPath } from '@/utils/roleRedirect';
import { getApiUrl } from '@/config/urls';
import { clearAllDataForUnauthorized } from '@/utils/clearAllData';

// Flag para evitar loops infinitos durante carregamento e sincroniza√ß√£o
let isLoadingData = false;
let isSyncingStorages = false;

export interface AuthData {
  accessToken: string;
  refreshToken: string;
  user: {
    id: string;
    email: string;
    name: string;
    role: string;
    permissions: string[];
    institution_name?: string;
  };
  sessionId?: string;
  expiresIn: number;
}

export interface LoginResponse {
  success: boolean;
  data?: AuthData;
  message: string;
}

export class UnifiedAuthService {
  /**
   * Salva dados de autentica√ß√£o em todos os locais (localStorage, cookies, Redis)
   */
  static async saveAuthData(authData: AuthData): Promise<{
    success: boolean;
    sessionId?: string;
    message: string;
  }> {
    try {
      console.log('üíæ Salvando dados de autentica√ß√£o em todos os locais...');

      // 1. Salvar no localStorage
      this.saveToLocalStorage(authData);

      // 2. Salvar nos cookies
      this.saveToCookies(authData);

      // 3. Criar sess√£o no Redis
      const sessionData: SessionData = {
        userId: authData.user.id,
        email: authData.user.email,
        role: authData.user.role,
        permissions: authData.user.permissions,
        loginTime: new Date().toISOString(),
        lastActivity: new Date().toISOString(),
        ipAddress: await this.getClientIP(),
        userAgent: navigator.userAgent,
        deviceInfo: this.getDeviceInfo()
      };

      const sessionResult = await SessionService.createSession(
        sessionData,
        authData.accessToken,
        authData.expiresIn
      );

      if (sessionResult.success && sessionResult.data) {
        // Atualizar sessionId nos outros locais de armazenamento
        const updatedAuthData = { ...authData, sessionId: sessionResult.data.sessionId };
        this.updateSessionId(sessionResult.data.sessionId);

        console.log('‚úÖ Dados salvos em todos os locais com sess√£o:', sessionResult.data.sessionId);
        
        return {
          success: true,
          sessionId: sessionResult.data.sessionId,
          message: 'Dados salvos com sucesso'
        };
      } else {
        console.warn('‚ö†Ô∏è Dados salvos localmente, mas sess√£o Redis falhou:', sessionResult.message);
        return {
          success: true,
          message: 'Dados salvos localmente (Redis indispon√≠vel)'
        };
      }

    } catch (error) {
      console.error('‚ùå Erro ao salvar dados de autentica√ß√£o:', error);
      return {
        success: false,
        message: 'Erro ao salvar dados de autentica√ß√£o'
      };
    }
  }

  /**
   * Carrega dados de autentica√ß√£o de todos os locais
   */
  static loadAuthData(): {
    localStorage: AuthData | null;
    cookies: AuthData | null;
    merged: AuthData | null;
  } {
    // Prote√ß√£o contra loop infinito
    if (isLoadingData) {
      console.warn('‚ö†Ô∏è Detectada chamada recursiva a loadAuthData(), retornando dados vazios');
      return {
        localStorage: null,
        cookies: null,
        merged: null
      };
    }

    try {
      isLoadingData = true;
      console.log('üìÇ Carregando dados de autentica√ß√£o...');

      const localStorageData = this.loadFromLocalStorage();
      const cookieData = this.loadFromCookies();

      // Priorizar dados mais recentes (localStorage geralmente √© mais atualizado)
      const merged = localStorageData || cookieData;

      console.log('üìã Dados carregados:', {
        hasLocalStorage: !!localStorageData,
        hasCookies: !!cookieData,
        hasMerged: !!merged
      });

      return {
        localStorage: localStorageData,
        cookies: cookieData,
        merged
      };
    } finally {
      isLoadingData = false;
    }
  }

  /**
   * Remove dados de autentica√ß√£o de todos os locais
   */
  static async clearAuthData(sessionId?: string | null, token?: string | null): Promise<void> {
    // 1. Remover do localStorage
    this.clearLocalStorage();

    // 2. Remover dos cookies
    CookieManager.clearAuthCookies();

    // 3. Remover sess√£o do Redis
    if (sessionId && token) {
      try {
        await SessionService.deleteSession(sessionId, token);
      } catch (error) {
        console.error('‚ùå Erro ao excluir sess√£o do Redis:', error);
        // Continuar mesmo com erro
      }
    }
  }

  /**
   * Realiza o logout completo do usu√°rio
   * Limpa todos os dados e redireciona para a p√°gina de login
   */
  static async performCompleteLogout(redirectToLogin: boolean = true): Promise<boolean> {
    try {
      console.log('üîì Iniciando logout completo...');
      
      // 1. Obter dados antes de limpar
      const token = this.getAccessToken();
      const sessionId = this.getSessionId();
      
      // 2. Chamar API de logout
      if (token) {
        try {
          await fetch(`${getApiUrl()}/auth/logout`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            credentials: 'include'
          });
          console.log('‚úÖ API de logout chamada com sucesso');
        } catch (err) {
          console.error('‚ö†Ô∏è Erro ao chamar API de logout:', err);
          // Continuar mesmo com erro na API
        }
      }
      
      // 3. Limpar dados de autentica√ß√£o
      await this.clearAuthData(sessionId, token);
      
      // 4. Limpar todos os outros dados
      await clearAllDataForUnauthorized();
      
      console.log('‚úÖ Logout completo realizado - todos os dados limpos');
      
      // 5. Redirecionar para login se solicitado
      if (redirectToLogin && typeof window !== 'undefined') {
        window.location.href = '/auth/login?logout=true';
      }
      
      return true;
    } catch (error) {
      console.error('‚ùå Erro durante logout completo:', error);
      
      // Tentar limpeza de emerg√™ncia
      try {
        if (typeof window !== 'undefined') {
          localStorage.clear();
          sessionStorage.clear();
          CookieManager.clearAuthCookies();
        }
      } catch (e) {
        console.error('‚ùå Erro na limpeza de emerg√™ncia:', e);
      }
      
      // Redirecionar mesmo com erro
      if (redirectToLogin && typeof window !== 'undefined') {
        window.location.href = '/auth/login?logout=error';
      }
      
      return false;
    }
  }

  /**
   * Atualiza token de acesso em todos os locais
   */
  static async updateAccessToken(newToken: string, sessionId?: string): Promise<void> {
    console.log('üîÑ Atualizando token de acesso...');

    try {
      // 1. Atualizar localStorage diretamente sem usar loadAuthData
      try {
        const userStr = localStorage.getItem('user');
        if (userStr && newToken) {
          localStorage.setItem('accessToken', newToken);
          localStorage.setItem('auth_token', newToken);
          localStorage.setItem('token', newToken);
          localStorage.setItem('authToken', newToken);
        }
      } catch (error) {
        console.error('‚ùå Erro ao atualizar token no localStorage:', error);
      }

      // 2. Atualizar cookies
      CookieManager.updateAccessToken(newToken);

      // 3. Estender sess√£o no Redis
      if (sessionId) {
        await SessionService.extendSession(sessionId, 60 * 60 * 2, newToken); // 2 horas
      }

      console.log('‚úÖ Token atualizado em todos os locais');
    } catch (error) {
      console.error('‚ùå Erro ao atualizar token:', error);
    }
  }

  /**
   * Verifica se o usu√°rio est√° autenticado
   */
  static isAuthenticated(): boolean {
    // Verificar diretamente no localStorage e cookies sem usar loadAuthData
    try {
      const lsToken = localStorage.getItem('accessToken') || 
                     localStorage.getItem('auth_token') || 
                     localStorage.getItem('token');
      
      if (lsToken) return true;
      
      const cookieToken = CookieManager.get('access_token');
      return !!cookieToken;
    } catch (error) {
      console.error('‚ùå Erro ao verificar autentica√ß√£o:', error);
      return false;
    }
  }

  /**
   * Obt√©m usu√°rio atual
   */
  static getCurrentUser(): any | null {
    try {
      // Tentar obter do localStorage primeiro
      const userStr = localStorage.getItem('user');
      if (userStr) {
        return JSON.parse(userStr);
      }
      
      // Se n√£o encontrar, tentar dos cookies
      return CookieManager.getAuthData().user;
    } catch (error) {
      console.error('‚ùå Erro ao obter usu√°rio atual:', error);
      return null;
    }
  }

  /**
   * Obt√©m token de acesso atual
   */
  static getAccessToken(): string | null {
    try {
      // Tentar obter do localStorage primeiro
      const token = localStorage.getItem('accessToken') || 
                    localStorage.getItem('auth_token') || 
                    localStorage.getItem('token');
      
      if (token) return token;
      
      // Se n√£o encontrar, tentar dos cookies
      return CookieManager.get('access_token');
    } catch (error) {
      console.error('‚ùå Erro ao obter access token:', error);
      return null;
    }
  }

  /**
   * Obt√©m ID da sess√£o atual
   */
  static getSessionId(): string | null {
    try {
      // Tentar obter do localStorage primeiro
      const sessionId = localStorage.getItem('sessionId');
      if (sessionId) return sessionId;
      
      // Se n√£o encontrar, tentar dos cookies
      return CookieManager.get('session_id');
    } catch (error) {
      console.error('‚ùå Erro ao obter sessionId:', error);
      return null;
    }
  }

  /**
   * Sincroniza dados entre storages
   */
  static syncStorages(): void {
    // Prote√ß√£o contra loop infinito
    if (isSyncingStorages) {
      console.warn('‚ö†Ô∏è Detectada chamada recursiva a syncStorages(), abortando');
      return;
    }

    try {
      isSyncingStorages = true;
      
      // Carregar dados sem usar loadAuthData para evitar loops
      let user = null;
      let accessToken = null;
      let refreshToken = null;
      let sessionId: string | undefined = undefined;
      
      try {
        // Tentar obter do localStorage
        const userStr = localStorage.getItem('user');
        if (userStr) user = JSON.parse(userStr);
        accessToken = localStorage.getItem('accessToken');
        refreshToken = localStorage.getItem('refreshToken');
        const storedSessionId = localStorage.getItem('sessionId');
        if (storedSessionId) sessionId = storedSessionId;
        
        // Se n√£o encontrar no localStorage, tentar dos cookies
        if (!user || !accessToken || !refreshToken) {
          const cookieData = CookieManager.getAuthData();
          if (!user && cookieData.user) user = cookieData.user;
          if (!accessToken && cookieData.accessToken) accessToken = cookieData.accessToken;
          if (!refreshToken && cookieData.refreshToken) refreshToken = cookieData.refreshToken;
          if (!sessionId && cookieData.sessionId) sessionId = cookieData.sessionId || undefined;
        }
        
        // Se temos dados suficientes, salvar em ambos os lugares
        if (user && accessToken && refreshToken) {
          // Garantir que os tipos est√£o corretos para a interface AuthData
          const authData: AuthData = {
            user,
            accessToken,
            refreshToken,
            sessionId,
            expiresIn: 0
          };
          
          this.saveToLocalStorage(authData);
          this.saveToCookies(authData);
          console.log('‚úÖ Dados sincronizados entre storages');
        }
      } catch (error) {
        console.error('‚ùå Erro ao sincronizar storages:', error);
      }
    } finally {
      isSyncingStorages = false;
    }
  }

  /**
   * Atualiza atividade do usu√°rio
   */
  static async updateActivity(): Promise<void> {
    try {
      const sessionId = this.getSessionId();
      const token = this.getAccessToken();
      
      if (sessionId && token) {
        await SessionService.updateActivity(sessionId, token);
      }
    } catch (error) {
      console.error('‚ùå Erro ao atualizar atividade:', error);
    }
  }

  private static saveToLocalStorage(authData: AuthData): void {
    try {
      localStorage.setItem('accessToken', authData.accessToken);
      localStorage.setItem('refreshToken', authData.refreshToken);
      localStorage.setItem('user', JSON.stringify(authData.user));
      
      if (authData.sessionId) {
        localStorage.setItem('sessionId', authData.sessionId);
      }
      
      // Salvar tamb√©m em chaves legadas para compatibilidade
      localStorage.setItem('auth_token', authData.accessToken);
      localStorage.setItem('token', authData.accessToken);
      localStorage.setItem('authToken', authData.accessToken);
    } catch (error) {
      console.error('‚ùå Erro ao salvar no localStorage:', error);
    }
  }

  private static loadFromLocalStorage(): AuthData | null {
    try {
      const accessToken = localStorage.getItem('accessToken');
      const refreshToken = localStorage.getItem('refreshToken');
      const userStr = localStorage.getItem('user');
      const sessionId = localStorage.getItem('sessionId');

      if (!accessToken || !refreshToken || !userStr) {
        return null;
      }

      const user = JSON.parse(userStr);

      return {
        accessToken,
        refreshToken,
        user,
        sessionId: sessionId || undefined,
        expiresIn: 0 // Ser√° calculado se necess√°rio
      };
    } catch (error) {
      console.error('‚ùå Erro ao carregar do localStorage:', error);
      return null;
    }
  }

  private static clearLocalStorage(): void {
    try {
      // Limpar tokens principais
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('user');
      localStorage.removeItem('sessionId');
      
      // Limpar tokens legados
      localStorage.removeItem('auth_token');
      localStorage.removeItem('token');
      localStorage.removeItem('authToken');
      localStorage.removeItem('user_data');
      
      console.log('üßπ localStorage limpo');
    } catch (error) {
      console.error('‚ùå Erro ao limpar localStorage:', error);
    }
  }

  private static saveToCookies(authData: AuthData): void {
    CookieManager.setAuthCookies({
      accessToken: authData.accessToken,
      refreshToken: authData.refreshToken,
      user: authData.user,
      sessionId: authData.sessionId
    });
  }

  private static loadFromCookies(): AuthData | null {
    try {
      const cookieData = CookieManager.getAuthData();

      if (!cookieData.accessToken || !cookieData.refreshToken || !cookieData.user) {
        return null;
      }

      return {
        accessToken: cookieData.accessToken,
        refreshToken: cookieData.refreshToken,
        user: cookieData.user,
        sessionId: cookieData.sessionId || undefined,
        expiresIn: 0
      };
    } catch (error) {
      console.error('‚ùå Erro ao carregar dos cookies:', error);
      return null;
    }
  }

  private static updateSessionId(sessionId: string): void {
    try {
      localStorage.setItem('sessionId', sessionId);
      CookieManager.set('session_id', sessionId, {
        maxAge: 60 * 60 * 24, // 1 dia
        secure: true,
        sameSite: 'lax'
      });
    } catch (error) {
      console.error('‚ùå Erro ao atualizar sessionId:', error);
    }
  }

  private static async getClientIP(): Promise<string> {
    try {
      const response = await fetch('https://api.ipify.org?format=json');
      const data = await response.json();
      return data.ip;
    } catch (error) {
      return 'unknown';
    }
  }

  private static getDeviceInfo(): string {
    const platform = navigator.platform;
    const userAgent = navigator.userAgent;
    return `${platform} - ${userAgent}`;
  }
} 