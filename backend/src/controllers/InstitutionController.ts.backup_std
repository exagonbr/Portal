import { Request, Response } from 'express';
import { BaseController } from './BaseController';
import { InstitutionRepository, InstitutionFilters } from '../repositories/InstitutionRepository';
import { Institution } from '../entities';
import { PaginationOptions } from '../types/pagination';

class InstitutionController extends BaseController<Institution> {
  private institutionRepository: InstitutionRepository;

  constructor() {
    const repository = new InstitutionRepository();
    super(repository);
    this.institutionRepository = repository;
  }

 public async getAll(req: Request, res: Response): Promise<Response> {
  try {
   // Aumentar o timeout para evitar problemas com grandes conjuntos de dados
   const timeoutPromise = new Promise((_, reject) => {
     setTimeout(() => reject(new Error('Timeout na busca de Instituições')), 60000); // 60 segundos
   });

   const { page = '1', limit = '10', search, state, is_active, has_student_platform, has_principal_platform, has_library_platform } = req.query;
   
   // Limitar o número máximo de itens para evitar sobrecarga
   let limitValue = parseInt(limit as string, 10);
   if (limitValue > 1000) {
     limitValue = 1000; // Limitar a 1000 itens por página no máximo
     console.log(`Limite ajustado para 1000 (solicitado: ${limit})`);
   }
   
   const paginationOptions: PaginationOptions = {
    page: parseInt(page as string, 10),
    limit: limitValue
   };
   
   const filters: InstitutionFilters = {};
   
   if (search) filters.search = search as string;
   if (state) filters.state = state as string;
   if (is_active !== undefined) filters.is_active = is_active === 'true';
   if (has_student_platform !== undefined) filters.has_student_platform = has_student_platform === 'true';
   if (has_principal_platform !== undefined) filters.has_principal_platform = has_principal_platform === 'true';
   if (has_library_platform !== undefined) filters.has_library_platform = has_library_platform === 'true';
   
   // Adicionar log para debug
   console.log(`Buscando instituições com filtros: ${JSON.stringify(filters)} e paginação: ${JSON.stringify(paginationOptions)}`);
   
   const institutionsPromise = this.institutionRepository.findWithFilters(filters, paginationOptions);
   
   // Usar Promise.race para aplicar timeout
   const result = await Promise.race([institutionsPromise, timeoutPromise]) as any;
   
   if (!result) {
     return res.status(404).json({ success: false, message: 'Instituições não encontradas' });
   }
   
   // Log para debug
   console.log(`Encontradas ${result.total} instituições`);
   
   return res.json({
    success: true,
    data: {
      items: result.items,
      pagination: {
        total: result.total,
        page: paginationOptions.page,
        limit: paginationOptions.limit,
        totalPages: Math.ceil(result.total / paginationOptions.limit!)
      }
    }
   });
  } catch (error) {
   console.error('Erro ao buscar instituições:', error);
   
   // Se for timeout, retornar erro específico
   if (error instanceof Error && error.message.includes('Timeout')) {
     return res.status(504).json({ 
       success: false, 
       message: 'Timeout na busca de Instituições - operação demorou muito',
       code: 'TIMEOUT_ERROR'
     });
   }
   
   return res.status(500).json({ 
     success: false, 
     message: 'Erro interno do servidor: ' + error,
     code: 'INTERNAL_ERROR'
   });
  }
 }

 public async toggleStatus(req: Request, res: Response): Promise<Response> {
  try {
   const { id } = req.params;
   const institution = await this.institutionRepository.toggleStatus(id);
   
   if (!institution) {
    return res.status(404).json({ message: 'Instituição não encontrada' });
   }
   
   return res.json(institution);
  } catch (error) {
   console.error('Erro ao alterar status da instituição:', error);
   return res.status(500).json({ message: 'Erro interno do servidor' });
  }
 }

 public async getStats(req: Request, res: Response): Promise<Response> {
  try {
  const { id } = req.params;
   const institution = await this.institutionRepository.findById(id);
   
   if (!institution) {
    return res.status(404).json({ message: 'Instituição não encontrada' });
   }
   
   const stats = await this.institutionRepository.getStats(id);
   return res.json(stats);
  } catch (error) {
   console.error('Erro ao buscar estatísticas da instituição:', error);
   return res.status(500).json({ message: 'Erro interno do servidor' });
  }
 }

 public async getUsers(req: Request, res: Response): Promise<Response> {
  try {
  const { id } = req.params;
   const { page = '1', limit = '10' } = req.query;
   
   const institution = await this.institutionRepository.findById(id);
   
   if (!institution) {
    return res.status(404).json({ message: 'Instituição não encontrada' });
   }
   
   const paginationOptions: PaginationOptions = {
    page: parseInt(page as string, 10),
    limit: parseInt(limit as string, 10)
   };
   
   const result = await this.institutionRepository.getUsers(id, paginationOptions);
   
   return res.json({
    items: result.items,
    total: result.total,
    page: paginationOptions.page,
    limit: paginationOptions.limit,
    totalPages: Math.ceil(result.total / paginationOptions.limit!)
   });
  } catch (error) {
   console.error('Erro ao buscar usuários da instituição:', error);
   return res.status(500).json({ message: 'Erro interno do servidor' });
  }
 }

 public async getClasses(req: Request, res: Response): Promise<Response> {
  try {
  const { id } = req.params;
   const { page = '1', limit = '10' } = req.query;
   
   const institution = await this.institutionRepository.findById(id);
   
   if (!institution) {
    return res.status(404).json({ message: 'Instituição não encontrada' });
   }
   
   const paginationOptions: PaginationOptions = {
    page: parseInt(page as string, 10),
    limit: parseInt(limit as string, 10)
   };
   
   const result = await this.institutionRepository.getClasses(id, paginationOptions);
   
   return res.json({
    items: result.items,
    total: result.total,
    page: paginationOptions.page,
    limit: paginationOptions.limit,
    totalPages: Math.ceil(result.total / paginationOptions.limit!)
   });
  } catch (error) {
   console.error('Erro ao buscar turmas da instituição:', error);
   return res.status(500).json({ message: 'Erro interno do servidor' });
  }
 }

 public async getSchedules(req: Request, res: Response): Promise<Response> {
  try {
  const { id } = req.params;
   const { page = '1', limit = '10' } = req.query;
   
   const institution = await this.institutionRepository.findById(id);
   
   if (!institution) {
    return res.status(404).json({ message: 'Instituição não encontrada' });
   }
   
   const paginationOptions: PaginationOptions = {
    page: parseInt(page as string, 10),
    limit: parseInt(limit as string, 10)
   };
   
   const result = await this.institutionRepository.getSchedules(id, paginationOptions);
   
   return res.json({
    items: result.items,
    total: result.total,
    page: paginationOptions.page,
    limit: paginationOptions.limit,
    totalPages: Math.ceil(result.total / paginationOptions.limit!)
   });
  } catch (error) {
   console.error('Erro ao buscar agendamentos da instituição:', error);
   return res.status(500).json({ message: 'Erro interno do servidor' });
  }
 }

 public async getAnalytics(req: Request, res: Response): Promise<Response> {
  try {
  const { id } = req.params;
   const institution = await this.institutionRepository.findById(id);
   
   if (!institution) {
    return res.status(404).json({ message: 'Instituição não encontrada' });
   }
   
   const analytics = await this.institutionRepository.getAnalytics(id);
   return res.json(analytics);
  } catch (error) {
   console.error('Erro ao buscar analytics da instituição:', error);
   return res.status(500).json({ message: 'Erro interno do servidor' });
  }
 }
}

export default new InstitutionController();
